"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseArgs = void 0;
const constants_1 = require("../constants");
const camel_case_object_keys_1 = require("./utilities/camel-case-object-keys");
const find_option_config_1 = require("./utilities/find-option-config");
const insert_shorthands_1 = require("./utilities/insert-shorthands");
const map_arg_type_to_error_message_1 = require("./utilities/map-arg-type-to-error-message");
const map_arg_type_to_value_parser_1 = require("./utilities/map-arg-type-to-value-parser");
const parse_option_1 = require("./utilities/parse-option");
const sort_object_by_key_1 = require("./utilities/sort-object-by-key");
const parse_boolean_1 = require("./utilities/value-parser/parse-boolean");
function parseArgs(args, positionalsConfig, optionsConfig, shorthandsConfig) {
    const argsCopy = typeof shorthandsConfig === 'undefined'
        ? args.slice()
        : insert_shorthands_1.insertShorthands(args, shorthandsConfig);
    const positionals = {};
    const options = {};
    const remainder = [];
    let stopParsingOptions = false;
    let positionalCount = 0;
    let index = -1;
    while (++index < argsCopy.length) {
        const currentArg = argsCopy[index];
        const currentOption = parse_option_1.parseOption(currentArg);
        if (stopParsingOptions === false) {
            if (currentArg === constants_1.stopParsingOptionsArg) {
                stopParsingOptions = true;
                continue;
            }
            if (currentOption !== null && typeof optionsConfig !== 'undefined') {
                const currentOptionConfig = find_option_config_1.findOptionConfig(currentOption.name, optionsConfig);
                if (currentOption.value !== null) {
                    const flag = currentArg.slice(0, currentArg.indexOf('='));
                    if (currentOptionConfig === null) {
                        throw new Error(`Invalid option: ${flag}`);
                    }
                    if (typeof options[currentOptionConfig.name] !== 'undefined') {
                        throw new Error(`Duplicate option: ${flag}`);
                    }
                    try {
                        if (currentOptionConfig.type === 'STRING') {
                            options[currentOptionConfig.name] = currentOption.value;
                            index++;
                            continue;
                        }
                        const parseValue = map_arg_type_to_value_parser_1.mapArgTypeToValueParser(currentOptionConfig.type);
                        const value = parseValue(currentOption.value, `Option ${flag}`);
                        options[currentOptionConfig.name] = value;
                        index++;
                        continue;
                    }
                    catch (error) {
                        if (error.message === '') {
                            throw new Error(`Invalid value for option ${flag}: '${currentOption.value}'`);
                        }
                        throw error;
                    }
                }
                if (currentOptionConfig !== null) {
                    if (typeof options[currentOptionConfig.name] !== 'undefined') {
                        throw new Error(`Duplicate option: ${currentArg}`);
                    }
                    const nextArg = argsCopy[index + 1];
                    if (currentOptionConfig.type === 'BOOLEAN') {
                        options[currentOptionConfig.name] = true;
                        try {
                            const boolean = parse_boolean_1.parseBoolean(nextArg, `${currentArg}`);
                            options[currentOptionConfig.name] = boolean;
                            index++;
                            continue;
                        }
                        catch {
                            continue;
                        }
                    }
                    if (typeof nextArg === 'undefined' ||
                        nextArg === constants_1.stopParsingOptionsArg) {
                        throw new Error(map_arg_type_to_error_message_1.mapArgTypeToErrorMessage(currentOptionConfig.type, `Option ${currentArg}`));
                    }
                    const nextOption = parse_option_1.parseOption(nextArg);
                    if (nextOption !== null) {
                        const nextOptionConfig = find_option_config_1.findOptionConfig(nextOption.name, optionsConfig);
                        if (nextOptionConfig !== null) {
                            throw new Error(map_arg_type_to_error_message_1.mapArgTypeToErrorMessage(currentOptionConfig.type, `Option ${currentArg}`));
                        }
                    }
                    try {
                        const parseValue = map_arg_type_to_value_parser_1.mapArgTypeToValueParser(currentOptionConfig.type);
                        const value = parseValue(nextArg, `Option ${currentArg}`);
                        options[currentOptionConfig.name] = value;
                        index++;
                        continue;
                    }
                    catch (error) {
                        if (nextOption !== null &&
                            typeof currentOptionConfig.type !== 'function') {
                            throw new Error(map_arg_type_to_error_message_1.mapArgTypeToErrorMessage(currentOptionConfig.type, `Option ${currentArg}`));
                        }
                        if (error.message === '') {
                            throw new Error(`Invalid value for option ${currentArg}: '${nextArg}'`);
                        }
                        throw error;
                    }
                }
            }
        }
        const isInvalidOption = currentOption !== null && stopParsingOptions === false;
        if (typeof positionalsConfig === 'undefined' ||
            positionalCount >= positionalsConfig.length) {
            if (isInvalidOption === true) {
                throw new Error(`Invalid option: ${currentArg}`);
            }
            remainder.push(currentArg);
            continue;
        }
        const positionalConfig = positionalsConfig[positionalCount];
        const positionalName = positionalConfig.name;
        try {
            const parseValue = map_arg_type_to_value_parser_1.mapArgTypeToValueParser(positionalConfig.type);
            const value = parseValue(currentArg, `Argument <${positionalName}>`);
            positionals[positionalName] = value;
            positionalCount++;
            continue;
        }
        catch (error) {
            if (isInvalidOption === true) {
                throw new Error(`Invalid option: ${currentArg}`);
            }
            if (error.message === '') {
                throw new Error(`Invalid value for argument <${positionalName}>: '${currentArg}'`);
            }
            throw error;
        }
    }
    if (typeof positionalsConfig !== 'undefined') {
        for (const positionalConfig of positionalsConfig) {
            if (typeof positionals[positionalConfig.name] === 'undefined') {
                if (typeof positionalConfig.default !== 'undefined') {
                    positionals[positionalConfig.name] = positionalConfig.default;
                    continue;
                }
                if (positionalConfig.required === true) {
                    throw new Error(`Argument <${positionalConfig.name}> is required`);
                }
            }
        }
    }
    if (typeof optionsConfig !== 'undefined') {
        for (const optionConfig of optionsConfig) {
            if (typeof options[optionConfig.name] === 'undefined') {
                if (typeof optionConfig.default !== 'undefined') {
                    options[optionConfig.name] = optionConfig.default;
                    continue;
                }
                if (optionConfig.required === true) {
                    throw new Error(`Option --${optionConfig.name} is required`);
                }
            }
        }
    }
    return {
        options: sort_object_by_key_1.sortObjectByKey(camel_case_object_keys_1.camelCaseObjectKeys(options)),
        positionals: sort_object_by_key_1.sortObjectByKey(camel_case_object_keys_1.camelCaseObjectKeys(positionals)),
        remainder
    };
}
exports.parseArgs = parseArgs;
